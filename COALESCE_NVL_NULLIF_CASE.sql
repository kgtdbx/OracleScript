До сих пор мы рассмотривали функции разделяя их по типам данных, с которыми они работают. Но сейчас мы будем рассматривать функции, которые работают с всеми типами данных (числами, символьными и типам дата), универсальные функции, также  обладают свойствами присущим только им. Это общии функции.

NVL

Функция NVL (expr1, expr2) возвращает значение expr1, в случае если expr1 is null, то функция NVL возвращает значение expr2. Данная функция может обрабатывать числовые, символьные, а также значения типа дата.
И еще повторимся:
expr1 – это то значение, которое возвращается в случае, если оно not null
expr2 – это то значение, которое возвращается в случае, если expr1 is null
 
SELECT ename, sal , comm, NVL (comm, 0)
FROM EMP

SELECT ename, sal , comm , sal + (sal* NVL (comm / 1000, 0)) total_sal
FROM EMP
 
Из примеров выше наглядно видно насколько полезной функцией является NVL. Особенно четко это видно во втором примере при подсчете бонусов к зарплате сотрудников учитывая поля comm.
NVL2
Функция NVL2 (expr1, expr2, expr3)
где
expr1 – это то выражение, которое будет анализироваться
expr2 – в случае expr1 “is not null” будет возвращено expr2
expr3 – в случае expr1 “is null”       будет возвращено expr3

SELECT ename, sal , comm , NVL2 (comm, sal + comm, sal) exmp_nvl2, sal+comm
FROM EMP

Как видно по примеру сперва мы проверяем значение колонки comm, на то что является ли ее значение null или нет. В случаи если comm is not null мы прибавляем к зарплате comm. Если же значение равно null, то в ответ не меняем значение sal. В последнем столбце мы видим результат правило, которое ранее в главах было описано  NUMBER+NULL=NULL.

NULLIF 

Функция NULLIF (expr1, expr2) cравнивать два выражения expr1 и expr2, в случае если они равны, то возвращает null, иначе возвращает значение expr1.
Привидем пример работы функции NULLIF:

SELECT ename, job , NULLIF (LENGTH(ename), LENGTH(job)) nullif_result
FROM EMP


COALESCE 

Функция COALESCE (expr1, expr2, …. , exprn)  возращает первое не нулевое значение из списка. Имеет следующий синтаксис:
В качестве выражений может выступать название столбца, который может быть любого типа.

SELECT comm , mgr, COALESCE (comm , mgr , 0)

FROM EMP

Осталось еще две основные функции, о которых стоит поговорить. Попросим вас внимательно их рассмотреть, так как на практике это очень часто встречаемые и полезные функции.
CASE 

Наверное если вы знакомы с програмированием вам будет знакомым этот условный опратор. Так вот это функция выполняют эти же функции в SQL. Поясним синтаксис функции CASE:
 
CASE expr WHEN comparison_expr_1 then return_expr_1 

WHEN comparison_expr_2 then return_expr_2 

WHEN comparison_expr_n then return_expr_n 

 ELSE else_expr 

END 
 
где
expr – это то выражение, которое сравнивается с comparison_expr_1 если оно совпадает, то выходит результат return_expr_1. Иначе идет вторая проверка и так до n-ой проверки. Если выражение не удовлетворило ни одну проверку comparison_expr_n, то в результате выйдет else_expr.

 
К примеру с таблицы EMP вывидим список сотрудников, при этом начисляя им бонусы в зависемоси от их рода работы.

SELECT job, sal,

CASE job  WHEN 'CLERK'   THEN sal*0.10

WHEN 'MANAGER' THEN sal*0.12

WHEN 'ANALYST' THEN sal*0.15

ELSE 0

END BONUS

FROM EMP



DECODE

Функция DECODE выполняет ту же функцию, что и CASE единственным отличием является ее синтаксис. Надо отметить, что исторически функция DECODE в SQL намного старьше, но ORACLE в виду более легкой читаемости CASE, ввел также данную конструкцию в свой SQL.

DECODE (expression, search_1, result_1,

 search_2, result_2,

 search_n, result_n, 

 default)

где
expression – это то выражение, которое сравнивается с search1, если оно совпадает, то выходит результат result1. Иначе идет вторая проверка и так далее до n-ой проверки. В конце в случаи всех неудачных проверок в результате выйдет default.

И перепишем верхний пример CASE, но при этом уже используя DECODE. Как ниже из примера мы видим, что никакой разницы в исполнение между CASE и DECODE нет.

SELECT job, sal,

CASE job  WHEN 'CLERK'   THEN sal*0.10

WHEN 'MANAGER' THEN sal*0.12

WHEN 'ANALYST' THEN sal*0.15

ELSE 0

END BONUS,

DECODE(job,'CLERK',  sal*0.10,

‘MANAGER',sal*0.12,

'ANALYST',sal*0.15,

0) BONUS_2

FROM EMP
