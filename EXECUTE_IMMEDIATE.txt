BEGIN
    EXECUTE IMMEDIATE 'CREATE SEQUENCE S_TEST START WITH 1 INCREMENT BY 1';
EXCEPTION
    WHEN OTHERS THEN
      IF SQLCODE = -955 THEN
        NULL; -- suppresses ORA-00955 exception
      ELSE
         RAISE;
      END IF;
END; 

----------
execute immediate 'begin :out_val := ' || gv_process.pkg_name||'.'||l_operation.check_empty||'; end;'
                using out l_chk_empty;
------------				
execute immediate 'begin '||gv_process.pkg_name||'.'||l_operation.procedure_name||'; end;';

--------------

begin
    if gv_process.save_state_proc is not null then
      execute immediate 'begin '||
                           gv_process.pkg_name||'.'||gv_process.save_state_proc||'(:p_curr_operation_cd,:p_curr_row_num);
                         end;'
        using ip_curr_operation_cd, ip_curr_row_num;
    end if;
  end;				
  
  

 CREATE OR REPLACE FUNCTION quote( 
in_v1 IN varchar2 
) 
RETURN varchar2 IS 
BEGIN 
return chr(39) || in_v1 || chr(39); 
--return replace(dbms_assert.enquote_name(in_v1),'"',chr(39)); 
END; 
/ 

-----
The syntax for the Oracle EXECUTE IMMEDIATE statement as follows:

EXECUTE IMMEDIATE <SQL or SPL Commands>
  [INTO <variable list>]
  [USING <bind variable list>];
Quotes and execute immediate
When executing a string variable that contains quotes it is important to "escape" the quote marks.

On 10g and beyond you can "escape" the quotes with two single quotes or a "q" and curly brackets:

For example, this "execute immediate" escapes the quotes with a q'{xxxxxxxx}'
sqlstring := q'{insert into x values( ' || i || ')}';

execute immediate sqlstring;


CREATE PROCEDURE fire_employee (emp_id NUMBER) AS
BEGIN
   EXECUTE IMMEDIATE
      'DELETE FROM employees WHERE employee_id = :id' USING emp_id;
END;
/

