Аналитические и агрегатные функции  

Разница и примеры аналитических функций и агрегатных

Агрегатная функция - возвращает 1 результирующую строку, которая основана на группе строк.
Агрегатные функции могут использоваться в списке select и конструкциях ORDER BY и HAVING.
Если агрегатная функция содержится в списке select, то агрегатная функция применится ко всем строкам результирующего набора. 
Если запрос содержит конструкцию GROUP BY, то агрегатная функция применится к каждой группе, полученной в результате группировки.
В HAVING агрегатные функции используются что бы исключить некоторые группы, основываясь на результатах агрегации групп, а не отдельных строк. 

Агрегатные функции (в документации их еще называют group by functions) - оперируют наборами значений. По умолчанию (если не определено другое) агрегатные ф-и игнорируют значения NULL.

Некоторые агрегатные функции 

AVG() Среднее значение агрумента 
BIT_AND() Битовое и 
BIT_OR() Битовое  или 
BIT_XOR() Битовое исключающее или 
COUNT(DISTINCT) Количество неповторяемых значений 
COUNT() Количество возвращенных строк 
GROUP_CONCAT() Конкатенированная строка 
MAX() Максимальное значение 
MIN() Минимальное значение 
SUM() Сумма 


Аналитические функции

Аналитические функции вычисляют агрегированное значение, основанное на группе строк. ОТЛИЧИЕ агрегатной от аналитической функции - аналитическая функция возвращает не 1 строку результата для группы, а множество строк для группы. 

Синтаксис аналитической функции:
analytic_function([ arguments ]) OVER (analytic_clause)
где analytic_clause 
 [ query_partition_clause ] [ order_by_clause [ windowing_clause ] ] 

Пример:
SELECT empno, deptno, sal, 
       FIRST_VALUE(sal IGNORE NULLS) OVER (PARTITION BY deptno ORDER BY sal ASC NULLS LAST)
AS first_val_in_dept
FROM   emp;
 
analytic_function = FIRST_VALUE
 analytic_clause = PARTITION BY deptno ORDER BY sal ASC NULLS LAST
 query_partition_clause =  PARTITION BY deptno
 order_by_clause = ORDER BY sal ASC NULLS LAST

Посмотрим на список некоторых аналитических функций: 
AVG *
CORR *
COUNT *
FIRST
FIRST_VALUE *
LAG
LAST
LAST_VALUE *
LEAD
LISTAGG
MAX *
MIN *
SUM *

Сравнив этот список со списком агрегатных ф-й видим, что одна и та же функция (например, AVG)  может быть и аналитической, и агрегатной.

Например:
Есть таблица с id сотрудника,номер департамента, и зарплатой сотрудника
table emp  |empno|deptno|salary|

     EMPNO     DEPTNO        SAL 
---------- ---------- ---------- 
      7782         10       2450   
      7839         10       5000  
      7934         10       1300   
      7566         20       2975         
      7902         20       3000        
      7876         20       1100         
      7369         20        800        
      7788         20       3000         
      7521         30       1250 
....
 
Используем ф-ю AVG(среднее значение) как агрегатную:

SELECT deptno, AVG(sal)
FROM   emp
GROUP BY deptno
ORDER BY deptno;

    DEPTNO   AVG(SAL)
---------- ----------
 10 2916.66667
 20  2175
 30 1566.66667

В данном случае, данные таблицы emp были сгруппированы по значению поля deptno, а агрегатная ф-я AVG вычислила среднее значение по полю sal для каждой группы. Как мы видим, агрегатная функция уменьшила количество результирующих столбцов.

Что произойдет, если мы захотим сравнить зарплату каждого сотрудника со средней по департаменту? В этом случае нужно использовать аналитическую AVG:

SELECT empno, deptno, sal,
       AVG(sal) OVER (PARTITION BY deptno) AS avg_dept_sal
FROM   emp;

     EMPNO     DEPTNO        SAL AVG_DEPT_SAL
---------- ---------- ---------- ------------
      7782         10       2450   2916.66667
      7839         10       5000   2916.66667
      7934         10       1300   2916.66667
      7566         20       2975         2175
      7902         20       3000         2175
      7876         20       1100         2175
      7369         20        800         2175
      7788         20       3000         2175
      7521         30       1250   1566.66667

В результате количество строк, в отличии от конструкции GROUP BY, не уменьшилось. Но вычисление средней суммы по департаменту выполнилось так же. Т.е. аналитическая функция выполнилась для каждой группы строк (группы вычислены  по условию PARTITION BY deptno - и набор строк в этих группах равен набору, который выбирался в группы условием group by в первом примере), и далее результат аналитической ф-и был присвоен каждой строке соответствующей группы.

НО следует обратить внимание на то, что результат выполнения аналитической ф-и зависит от того, задано ли условие PARTITION BY и ORDER BY.
При отсутствии условий PARTITION BY и ORDER BY результирующий набор строк рассматривается как одно окно (одна группа данных), результирующее значение аналитической ф-и будет присвоено каждой строке

 Например:
SELECT empno, deptno, 
       MAX(sal) OVER () AS avg_dept_sal
FROM   emp;

    EMPNO     DEPTNO        MAX(SAL) 
---------- ---------- ---------- 
      7782         10       5000
      7839         10       5000  
      7934         10       5000
      7566         20       5000
      7902         20       5000        
      7876         20       5000         
   ...
Т.е. все строки получат результирующее значение 5000

Если задать ORDER BY - вместо результирующего значения для каждой строки будет 
указано "промежуточное значение"
SELECT empno, deptno, 
       MAX(sal) OVER (ORDER BY empno) AS avg_dept_sal
FROM   emp;


EMPNO DEPTNO  MAX(SAL) 
----  ----- ---------- 
7566 20 2975
 7782 10 2975
 7839 10 5000
 7876 20 5000
 7902 20 5000
 7934 10 5000

Если выполнять сортировку по другому полю, то промежуточные значения могуть поменяться, но финальное значение (в последней строке) будет одинаковым.


Ссылки: 
Агрегатные функции
http://docs.oracle.com/cd/E11882_01/server.112/e26088/functions003.htm
 http://docs.oracle.com/cd/E11882_01/server.112/e26088/functions004.htm
 group by http://my-oracle.it-blogs.com.ua/post-27.aspx

Аналитические функции
http://docs.oracle.com/cd/E11882_01/server.112/e26088/functions004.htm#SQLRF51208 
 http://www.oracle-base.com/articles/misc/analytic-functions.php 
 -----------************************************
В отличие от обычных скалярных функций аналитические функции берут аргументом SQL-таблицу, представляющую логический промежуточный результат обработки SQL-оператора, где использовано обращение к такой функции, и возвращают в качестве своего результата обычно тоже SQL-таблицу.

Цели введения аналитических функций в Oracle

Техническая цель введения аналитических функций - дать лаконичную формулировку и увеличить скорость выполнения "аналитических запросов" к БД, то есть запросов, имеющих смыслом выявление внутренних соотношений и зависимостей в данных. Более точно, пользование аналитическими функциями может дать следующие выгоды перед обычными SQL-операторами:
•Лаконичную и простую формулировку. Многие аналитические запросы к БД традиционными средствами сложно формулируются, а потому с трудом осмысливаются и плохо отлаживаются.

•Снижение нагрузки на сеть. То, что раньше могло формулироваться только серией запросов, сворачивается в один запрос. По сети только отправляется запрос и получается окончательный результат.

•Перенос вычислений на сервер. С использованием аналитических функций нет нужды организовывать расчеты на клиенте; они полностью проводятся на сервере, ресурсы которого могут быть более подходящи для быстрой обработки больших объемов данных.

•Лучшую эффективность обработки запросов. Аналитические функции имеют алгоритмы вычисления, неразрывно связанные со специальными планами обработки запросов, оптимизированными для большей скорости получения результата. 

Стратегическая цель введения в Oracle аналитических функций - дать базовое средство для построения ИС типа "складов данных" (data warehouse, DW), ИС "аналитического характера" (business intelligence systems, BI) или OLAP-систем. По представлениям разработчиков, набор таких базовых средств помимо аналитических функций формируют еще и прочие средства Oracle, такие как
•конструкции ROLLUP, CUBE и связанные с ними в предложениях с GROUP BY

•материализованные выводимые таблицы (materialized views) 

Классификация видов аналитических функций в Oracle

Согласно классификации из документации по Oracle, аналитические функции могут быть следующих видов:

(a) функции ранжирования
(b) статистические функции для плавающего интервала
(c) функции подсчета долей
(d) статистические функции LAG/LEAD с запаздывающим/опережающим аргументом
(e) статистические функции (линейная регрессия и т. д.)

Основные технические особенности

Место указания аналитических функций в SQL-предложении

Аналитические функции принимают в качестве аргумента столбец промежуточного результата вычисления SQL-предложения и возвращают тоже столбец. Поэтому местом их использования в SQL-предложении могут быть только фразы ORDER BY и SELECT, выполняющие завершающую обработку логического промежуточного результата.

Сравнение с обычными функциями агрегирования

Многие аналитические функции действуют подобно обычным скалярным функциям агрегирования SUM, MAX и прочим, примененным к группам строк, сформированным с помощью GROUP BY. Однако обычные функции агрегирования уменьшают степень детализации, а аналитические функции нет. Поясняющий сравнительный пример:

SELECT deptno, job, SUM(sal) sum_sal
FROM emp
GROUP BY deptno, job;

SELECT ename, deptno, job, 
            SUM(sal) OVER (PARTITION BY deptno, job) sum_sal    
FROM emp;

Особенности обработки

Построим в SQL*Plus планы для двух запросов выше:

SET AUTOTRACE TRACEONLY EXPLAIN

SELECT deptno, job, SUM(sal) sum_sal
FROM emp
GROUP BY deptno, job;

SELECT empno, deptno, job, 
SUM(sal) OVER (PARTITION BY deptno, job) sum_sal
FROM emp;

SET AUTOTRACE OFF

Обратим внимание на однопроходность и специальный шаг плана второго запроса (шаг WINDOW).

Разбиение данных на группы для вычислений

Аналитические функции агрегируют данные порциями (partitions; группами), количество и размер которых можно регулировать специальной синтаксической конструкцией. Ниже она указана на примере агрегирующей функции SUM:

SUM(выражение 1) OVER([PARTITION BY выражение 2 [, выражение 3 [, …]]])

Пример использования такой конструкции см. выше.

Если PARTITION BY не указано, то в качестве единственной группы для вычислений будет взят полный набор строк:

SELECT ename, deptno, job, 
SUM(sal) OVER () sum_sal
FROM emp;

Упорядочение в границах отдельной группы

С помощью синтаксической конструкции ORDER BY строки в группах вычислений можно упорядочивать. Синтаксис иллюстрируется на примере агрегирующей функции SUM:

SUM(выражение 1) OVER([PARTITION …] 
ORDER BY выражение 2 [,…] [{ASC/DESC}] [{NULLS FIRST/NULLS LAST}])

Правила работы ORDER BY - как в обычных SQL-операторах. Пример:

SELECT ename, deptno, job,
SUM(sal) OVER (PARTITION BY deptno, job ORDER BY hiredate) sum_sal
FROM emp;

ENAME             DEPTNO           JOB                            SUM_SAL
-                    -                                   -
MILLER 10 CLERK 1300   
CLARK 10 MANAGER 2450   
KING 10 PRESIDENT 5000   
FORD 20 ANALYST 3000 <- - порядок и сумма изменились 
SCOTT 20 ANALYST 6000   
SMITH 20 CLERK 800 <- - порядок и сумма изменились 
ADAMS 20 CLERK 1900   
JONES 20 MANAGER 2975   
JAMES 30 CLERK 950   
BLAKE 30 MANAGER 2850   
ALLEN 30 SALESMAN 1600 <- - порядок и сумма изменились 
WARD 30 SALESMAN 2850   
TURNER 30 SALESMAN 4350   
MARTIN 30 SALESMAN 5600   

14 rows selected.

В группах из более одной строки появился заданный порядок. Природа изменения поля SUM_SAL в пределах групп из нескольких строк станет ясна из следующего раздела.

Выполнение вычислений для строк в группе по плавающему окну (интервалу)

Для некоторых аналитических функций, например, агрегирующих, можно дополнительно указать объем строк, участвующих в вычислении, выполняемом для каждой строки в группе. Этот объем, своего рода контекст строки, называется "окном", а границы окна могут задаваться различными способами.

{ROWS / RANGE} {{UNBOUNDED / выражение} PRECEDING / CURRENT ROW }

{ROWS / RANGE} 
BETWEEN 
{{UNBOUNDED PRECEDING / CURRENT ROW / 
{UNBOUNDED / выражение 1}{PRECEDING / FOLLOWING}} 
AND 
{{UNBOUNDED FOLLOWING / CURRENT ROW / 
{UNBOUNDED / выражение 2}{PRECEDING / FOLLOWING}} 

Фразы PRECEDING и FOLLOWING задают верхнюю и нижнюю границы агрегирования (то есть интервал строк, "окно" для агрегирования).

Вот поясняющий пример, воспроизводящий результат из предыдущего раздела:

SELECT ename, deptno, job,
SUM(sal) 
OVER (PARTITION BY deptno, job ORDER BY hiredate 
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) sum_sal
FROM emp;

Здесь в пределах каждой группы (использована фраза PARTITION BY) сотрудники упорядочиваются по времени найма на работу (фраза ORDER BY) и для каждого в группе вычисляется сумма зарплат: его и всех его предшественников (фраза ROWS BETWEEN формулирует "окошко суммирования" от первого в группе до текущего рассматриваемого).

Выделенная в последнем запросе жирным цветом фраза подразумевается по умолчанию, если она попросту отсутствует (ср. с запросом из предыдущего раздела).

Обратите внимание, что плавающий интервал задается в терминах упорядоченных строк (ROWS) или значений (RANGE), для чего фраза ORDER BY в определении группы обязана присутствовать.

Формирование интервалов агрегирования "по строкам" и "по значениям"

Разницу между ROWS и RANGE (определяющими, как говорится в документации, "физические" и "логические" интервалы-окна) удобно продемонстрировать следующим примером:

SELECT ename, hiredate, sal,
SUM(sal)
OVER (ORDER BY hiredate
ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) rows_sal,
SUM(sal)
OVER (ORDER BY hiredate
RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) range_sal
FROM emp;

JAMES и FORD поступили на работу одновременно, и с точки зрения интервала суммирования неразличимы. Поэтому суммирование "по значению" присвоило им один и тот же общий для "мини-группы", образованной этой парой, результат - максимальную сумму, которая при всех возможных порядках перечисления сотрудников внутри этой пары будет всегда одинакова. Суммирование "по строкам" (ROWS) поступило иначе: оно упорядочило сотрудников в "мини-группе", образованной равными датами (на самом деле чисто произвольно) и подсчитало суммы, как будто бы у этих сотрудников был задан порядок следования.

Функции FIRST_VALUE и LAST_VALUE для интервалов агрегирования

Эти функции позволяют для каждой строки выдать первое значение ее окна и последнее. Пример:

SELECT ename, hiredate, sal,
FIRST_VALUE(sal)
OVER (ORDER BY hiredate
ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) first_rows,
LAST_VALUE(sal)
OVER (ORDER BY hiredate
ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) last_rows,
FIRST_VALUE(sal)
OVER (ORDER BY hiredate
RANGE BETWEEN 2 PRECEDING AND CURRENT ROW) first_range,
LAST_VALUE(sal)
OVER (ORDER BY hiredate
RANGE BETWEEN 2 PRECEDING AND CURRENT ROW) last_range 
FROM emp;


Интервалы времени

Для интервалов (окон), упорядоченных внутри по значению ("логическом", RANGE) в случае, если это значение имеет тип "дата", границы интервала можно указывать выражением над датой, а не конкретными значениями из строк. Примеры таких выражений:

INTERVAL число {YEAR / MONTH / DAY / HOUR / MINUTE / SECOND}

NUMTODSINTERVAL(число, '{DAY / HOUR / MINUTE / SECOND}')

NUMTOYMINTERVAL(число, '{YEAR / MONTH}')

Пример выдачи зарплат сотрудников и средних зарплат за последние полгода на момент приема нового сотрудника:

SELECT ename, hiredate, sal,
AVG(sal)
OVER (ORDER BY hiredate
RANGE BETWEEN INTERVAL '6' MONTH PRECEDING AND CURRENT ROW) avg_sal
FROM emp;

Вот другая запись для того же запроса, но позволяющая использовать для числа месяцев обычное числовое выражение:

SELECT ename, hiredate, sal,
AVG(sal)
OVER (ORDER BY hiredate
RANGE BETWEEN NUMTOYMINTERVAL(6, 'MONTH') PRECEDING 
AND CURRENT ROW) avg_sal
FROM emp;

Виды аналических функций

В качестве базовой в аналитической функции могут быть указаны традиционные для Oracle статистические (агрегатные, то есть обобщающие) функции COUNT, MIN, MAX, SUM, AVG и другие ("стандартные агрегатные функции" по документации). Примеры приводились выше. Можно обратить внимание на то, что аналитические функции со статистическими агрегатами разумно обрабатывают NULL:

SELECT ename, hiredate, sal,
AVG(sal)
OVER (ORDER BY hiredate
RANGE BETWEEN UNBOUNDED PRECEDING AND INTERVAL '1' SECOND PRECEDING) avg_sal
FROM emp;

Ниже приводится полный перечень аналитических функций в версии СУБД 9.2:



AVG * 
CORR * 
COVAR_POP * 
COVAR_SAMP * 
COUNT * 
CUME_DIST 
DENSE_RANK 
FIRST 
FIRST_VALUE * 
LAG 
LAST
  LAST_VALUE * 
LEAD 
MAX * 
MIN * 
NTILE 
PERCENT_RANK 
PERCENTILE_CONT 
PERCENTILE_DISC 
RANK 
RATIO_TO_REPORT
  REGR_ (вид_функции_линейной_регрессии) * 
ROW_NUMBER 
STDDEV * 
STDDEV_POP * 
STDDEV_SAMP * 
SUM * 
VAR_POP * 
VAR_SAMP * 
VARIANCE 
  

Звездочкой помечены функции, допускающие использование плавающего интервала расчета.

Некоторые из этих функций рассматриваются ниже.

Функции ранжирования

Функции ранжирования позволяют "раздать" строкам "места" в зависимости от имеющихся в них значениях. Некоторые примеры:

SELECT ename, sal, 
            ROW_NUMBER () OVER (ORDER BY sal DESC) AS salbacknumber, 
            ROW_NUMBER () OVER (ORDER BY sal) AS salnumber,
            RANK() OVER (ORDER BY sal) AS salrank,
            DENSE_RANK() OVER (ORDER BY sal) AS saldenserank 
FROM emp;

(раздать сотрудникам места в порядке убывания/возрастания зарплат)

Функции подсчета долей

Функции подсчета долей позволяют одной SQL-операцией получить для каждой строки ее "вес" в таблице в соответствии с ее значениями. Некоторые примеры:

SELECT ename, sal, RATIO_TO_REPORT(sal) OVER () AS salshare FROM emp;

(доли сотрудников в общей сумме зарплат)

Пример выдачи доли сотрудников с меньшей или равной зарплатой, чем у "текущего":

SELECT job, ename, sal, 
CUME_DIST() OVER (PARTITION BY job ORDER BY sal) AS cume_dist
FROM emp;


(видно, что три четверти клерков имеют зарплату, меньше чем ADAMS).

Проранжировать эту выдачу по доле сотрудников в группе можно функцией PERCENT_RANK:

SELECT job, ename, sal, 
CUME_DIST() OVER (PARTITION BY job ORDER BY sal) AS cume_dist,
PERCENT_RANK() OVER (PARTITION BY job ORDER BY sal) AS pct_rank
FROM emp;

Процентный ранг отсчитывается от 0 и изменяется до 1.

Некоторые жизненные примеры аналитических запросов

Для типов сегментов, более других расходующих дисковое пространство, выдать главных пользователей, ответственных за такой расход

Построить такой запрос на основе таблицы SYS.DBA_SEGMENTS, можно пошагово.

Шаг 1. Выдать типы сегментов в БД, общий объем памяти на диске для каждого типа и долю числа типов с равным или меньшим общим объемом памяти:

SELECT segment_type, 
      SUM(bytes) bytes,
      CUME_DIST() OVER (ORDER BY SUM(bytes)) bytes_percentile
      FROM sys.dba_segments
      GROUP BY segment_type;

Шаг 2. Отобрать 40% "наиболее расточительных" по дисковой памяти типов:

SELECT * 
FROM
(SELECT segment_type, 
SUM(bytes) bytes,
CUME_DIST() OVER (ORDER BY SUM(bytes)) bytes_percentile
FROM sys.dba_segments
GROUP BY segment_type)
WHERE bytes_percentile >= 0.5;

Шаг 3. Отобрать пользователей, занимающих первые пять мест по расходованию памяти среди "наиболее расточительных" типов сегментов:

SELECT * 
FROM
(
SELECT owner,
        SUM(bytes) bytes,
        RANK() OVER(ORDER BY SUM(bytes) DESC) bytes_rank
FROM sys.dba_segments
WHERE segment_type IN
      (SELECT segment_type
        FROM
           (SELECT segment_type, 
                SUM(bytes) bytes,
                CUME_DIST() OVER (ORDER BY SUM(bytes)) bytes_percentile
                FROM sys.dba_segments
                GROUP BY segment_type)
        WHERE bytes_percentile >= 0.5)
GROUP BY owner
)
WHERE bytes_rank <=5
/

Выдать список периодов наиболее активного переключения журнальных файлов БД

Список переключений журнальных файлов хранится в динамической таблице v$loghist. Ниже приводится один из вариантов запроса.

var treshold number
exec :treshold := 30
alter session set nls_date_format='MON-DD HH24:MI:SS';

SELECT 
start_time,
end_time,
ROUND((end_time - start_time)*24*60, 2) delta_min,
switches,
switches / ((end_time - start_time)*24*60) per_minute
FROM
(
SELECT
MIN(time_stamp) start_time,
MAX(time_stamp) end_time,
count (*) switches
FROM
(
SELECT time_stamp, freq10, more,
SUM(ABS(indicator)) OVER (ORDER BY time_stamp) part
FROM
(
SELECT time_stamp, freq10,
SIGN(freq10 - :treshold - 0.5) more,
SIGN(freq10 - :treshold - 0.5) - LAG(SIGN(freq10 - :treshold - 0.5), 1)
OVER (ORDER BY time_stamp) indicator
FROM
(
SELECT first_time time_stamp,
GREATEST(
COUNT(*)
OVER (ORDER BY first_time
RANGE BETWEEN CURRENT ROW AND INTERVAL '10' MINUTE FOLLOWING)
,
COUNT(*)
OVER (ORDER BY first_time
RANGE BETWEEN INTERVAL '10' MINUTE PRECEDING AND CURRENT ROW)
) freq10
FROM v$loghist
) /* frequency table */
) /* frequency treshold overcome table */
) /* transient partitioned table */
WHERE more > 0
GROUP BY part
)
WHERE (end_time - start_time)*24*60 > 0 
/

Пояснения
•Фактически проверяется не частота переключений журнальных файлов, а частота фиксации первого изменения в журнальных файлах. Это не совсем одно и то же, но, похоже, сильно коррелирующие события. 
•Результат получается в несколько проходов. Сначала для каждой записи проверяется средняя активность переключений в 10-минутные предшествующий и последующий интервалы. Затем выбираются записи, для которых средняя активность превышает порог :treshold = 30 в минуту. Затем размечаются точки перехода через порог, которые далее служат границами групп "повышенной" и "пониженной" активности. Потом интервалы с повышенной активностью выдаются на экран.

 
 