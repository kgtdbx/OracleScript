В оракле она начинаеться с любого оператора, если нет активных транзакцие, даже если это select, но при простом selecte oracle не заносит записи о начале транзакции в служебные таблицы.
И что тут непонятного???
--****************

juks@gala.net
С первого селекта или с первого DML оператора?
Транзакция начинается (см. ниже цитаты из документации и стандарта) в тот момент, когда не существует любой другой активной транзакции (исключая случаи начала автономной, рекурсивной и распределённой транзакции, которые могут проходить при наличии активной транзакции. При инициировании распределённой транзакцией в рамках уже начатой всё чуть сложнее -- она меняет аттрибуты/флаги основной, но это не меняет приниципа.) и происходит выполнение SQL-выражения, которое может начать транзакцию (например: SELECT/INSERT/UPDATE/DELETE/MERGE, SET TRANSACTION, SAVEPOINT). Нужно отметить, что в общем случае, умозаключение по поводу обязательного наличия undo segments ("выделение сегментов отката") ассоциированных с транзакцией неверно. Но это верное требование для транзакций изменяющих или способных изменить состояние базы данных. Существуют или существовали (кому как больше нравится) дискретные транзакции, которые начинаются вызовом dbms_transaction.begin_discrete_transaction. Также можно начать транзакцию используя dbms_transaction.local_transaction_id(create_transaction => TRUE). Oracle использует x$ktcxb для отоброжения состояния транзакций. Концептуально SELECT (как первое SQL-выражение) начинает транзакцию -- в простых случаях она не появляется в v$transaction/x$ktcxb, но этого и не требуется для работы. В общем случае, SELECT может начать транзакцию видимую в v$transaction/x$ktcxb -- скажем, SELECT FOR UPDATE или распределенный запрос. Про SELECT это из серии: "--Суслика видишь? --Нет --И я нет. А он есть!" (с) "ДМБ". Oracle не делает лишних телодвижений, поэтому для простых случаев запись о том что кто-то выполняет запрос (SELECT) в v$transaction не нужна.

Возможно, те цитаты которые ты привёл, были рядом с примерами иллюстрирующими принципы работу транзакций (A.C.I.D, etc.) -- у меня нет этих книг, поэтому сам посмотреть не могу. Да вообщем-то это и не столь важно. На мой взгляд у общественности есть чёткая ассоциация v$transaction -- транзакция, но в сущности, это не совсем так.
Oracle® Database Concepts 10g Release 2 (10.2)
1 Introduction to the Oracle Database
Overview of Transactions

A transaction is a logical unit of work that comprises one or more SQL statements run by a single user. According to the ANSI/ISO SQL standard, with which Oracle is compatible, a transaction begins with the user's first executable SQL statement. A transaction ends when it is explicitly committed or rolled back by that user. Note: Oracle is broadly compatible with the SQL-99 Core specification.
ISO International Standard (IS)
Database Language SQL - Part 2: Foundation (SQL/Foundation)
July 1999
4.32 SQL-transactions
An SQL-transaction is initiated when no SQL-transaction is currently active and an <externally-invoked procedure> is called that results in the execution of a transaction-initiating SQL-statement.
...
An SQL-transaction is terminated by a <commit statement> or a <rollback statement>.
...
Execution of a <set transaction statement> is prohibited after the start of an SQL-transaction and before its termination.
...
An SQL-transaction has an access mode that is either read-only or read-write. The access mode may be explicitly set by a <set transaction statement> before the start of an SQL-transaction or by the use of a <start transaction statement> to start an SQL- transaction; otherwise, it is implicitly set to the default access mode for the SQL-session before each SQL-transaction begins. If no <set session characteristics statement> has set the default access mode for the SQL-session, then the default access mode for the SQL- session is read-write. The term read-only applies only to viewed tables and persistent base tables.
Раздел "4.30.3 SQL-statements and transaction states" также рекомендован к прочтению.

--******************************
Логика работы транзакции. Операторы управления транзакциями. Особенности выполнения транзакции. Об этом данная статья. В ORACLE нет явного оператора, чтобы начать транзакцию, но и нет автоматического завершения транзакции. Транзакция автоматически начинается с первого оператора, который начал изменения, то есть установил блокировку TX . Заканчивается явным оператором окончания транзакции.
Операторы управления транзакциями:
COMMIT
ROLLBACK
SAVEPOINT
ROLLBACK TO
SET TRANSACTION
Приведу немного подробностей по каждому оператору.
COMMIT. Оператор COMMIT завершает транзакцию и делает любые выполненные в ней изменения постоянными. Освобождаются блокировки.
ROLLBACK. Оператор отката завершает транзакцию и отменяет все выполненные в ней и незафиксированные изменения. Для этого он читает информацию из сегментов отката и восстанавливает блоки данных в состояние, в котором они находились до начала транзакции. Освобождаются блокировки.
По завершении транзакции необходимо явно указывать одну из команд завершения транзакции иначе за вас это сделает среда, в которой вы работаете (а среда не всегда это делает так, как вы предполагаете).
SAVEPOINT. Позволяет создать в транзакции точку сохранения. В одной транзакции можно выполнять оператор SAVEPOINT несколько раз, устанавливая несколько точек сохранения. Точки сохранения позволяют устанавливать маркеры внутри транзакции таким образом, чтобы была возможность отмены только части работы, проделанной в транзакции. Оправдано использование точек сохранения в продолжительных и сложных транзакциях. ORACLE освобождает блокировки, которые были установлены отменённым оператором.
ROLLBACK TO <точка сохранения>. Этот оператор используется совместно с представленным выше оператором SAVEPOINT. Транзакцию можно откатить до указанной точки сохранения, не отменяя все сделанные до нее изменения. Таким образом, можно выполнить два оператора UPDATE, затем — оператор SAVEPOINT, а после него — два оператора DELETE. При возникновении ошибки или исключительной ситуации в ходе выполнения операторов DELETE транзакция будет откатываться до указанной оператором SAVEPOINT точки сохранения; при этом будут отменяться операторы DELETE, но не операторы UPDATE.
SET TRANSACTION. Этот оператор позволяет устанавливать атрибуты транзакции, такие как уровень изолированности и то, будет ли она использоваться только для чтения данных или для чтения и записи. Этот оператор также позволяет привязать транзакцию к определенному сегменту отката.
Некоторые особенности выполнения транзакций в ORACLE:
Транзакция обычно состоит из нескольких операторов DML . Если один оператор дает сбой, то он один откатывается. То есть все операторы, которые раньше были выполнены, не откатываются автоматически – результаты их работы не пропадают. Вы можете дальше продолжать транзакцию. Затем её или зафиксировать, или откатить. А получаем мы такой эффект потому, что ORACLE каждый оператор транзакции помещает в неявные операторы Savepoint так, как это показано далее:
Savepoint statement1;
Оператор1;
If error then rollback to statement1;
Savepoint statement2;
Оператор2;
If error then rollback to statement2;
Понятие неделимости распространяется на необходимую глубину. Например, мы вставляет записи в таблицу 1, что вызывает срабатывание триггера на вставку записей в таблицу 2, что в свою очередь вызывает срабатывание триггера на обновление таблицы 3 и так далее. Если в какой-то момент происходит откат нашего оператора по таблице 1, то отменяются и все изменения, произведенные в таблице 2,3, и т.д. То есть или все изменения фиксируются, или все отменяется.
ORACLE анонимный блок PL/SQL считает оператором. Например, begin оператор1; оператор2; end; То есть для него применимо предыдущее замечание.
Ограничение целостности проверяются после выполнения каждого sql-оператора. ORACLE разрешает делать некоторые строки таблицы несогласованными до конца выполнения sql-оператора.
В ORACLE есть возможность отложить проверку целостности на любой момент времени до конца транзакции. Это реализуется с помощью ограничения deferrable таблицы и перевода ограничения в режим deferred.
В целях экономии места в сегментах отката не фиксируйте изменения чаще, чем это нужно по логике программы. Просто нужно определить оптимальный размер сегментов отката.
В ORACLE можно использовать распределенные транзакции, то есть выполнять транзакцию, в которой операторы работают на удаленных сервера (распределенная база данных). Для доступа к удаленной базе данных используется объект database link. Распределённая транзакция выглядит примерно так:
update table1 set x=1; update remote_table1@remote_database set x=1; commit;
Распределённая транзакция имеет то же свойство, что и обычная: все или ничего. Только фиксация происходит в две стадии (двухфазная фиксация транзакции): сначала мастер-сервер опрашивает о готовности все подчинённые сервера, затем, в случае если все сервера готовы, дает команду фиксировать транзакцию. Если хотя бы один сервер при опросе был не готов, то транзакция откатывается на всех серверах.
В ORACLE продолжительность транзакции не ограничивается, потому что проблемы поедания ресурсов блокировками не существует. Транзакция длится столько, сколько нужно приложению. Единственная проблема: при очень длительных транзакциях и маленьком сегменте отката возможна ошибка ORA-1555.
В связи с тем, что мы сейчас разбираемся с понятием транзакции, мне кажется очень уместным привести выдержку из Тома Кайта:
При разработке приложений баз данных я использую очень простую мантру:
если можно, сделай это с помощью одного оператора SQL(потому что это будет быстрее);
если это нельзя сделать с помощью одного оператора SQL, сделай это в PL/SQL;
если это нельзя сделать в PL/SQL, попытайся использовать хранимую процедуру на языке Java;
если это нельзя сделать в Java, сделай это в виде внешней процедуры на языке С;
если это нельзя реализовать в виде внешней процедуры на языке С, надо серьезно подумать, зачем это вообще делать..